package io.github.ghostbuster91.sttp.client3

import sbt.{AutoPlugin, Def, File}
import sbt.Keys._
import sbt._
import org.scalafmt.interfaces.Scalafmt
import sbt.internal.util.ManagedLogger

object SttpOpenApiCodegenPlugin extends AutoPlugin {

  val sttpOpenApiOutputPath =
    settingKey[File](
      "Directory for sources generated by sttp-openapi generator"
    )
  val sttpOpenApiInputPath =
    settingKey[File]("Input resources for sttp-openapi generator")

  val sttpOpenApiJsonLibrary =
    settingKey[JsonLibrary]("Json library for sttp-openapi generator to use")

  val sttpOpenApiHandleErrors = settingKey[Boolean](
    "If true the generator will include error information in types"
  )

  object autoImport {

    lazy val generateSources =
      Def.task {
        val log = streams.value.log
        val targetDirectory = sttpOpenApiOutputPath.value
        val topLevelInputPath = sttpOpenApiInputPath.value
        val scalafmt = Scalafmt.create(this.getClass.getClassLoader)
        val config = CodegenConfig(
          handleErrors = sttpOpenApiHandleErrors.value,
          sttpOpenApiJsonLibrary.value
        )
        val codegen = new SbtCodegenAdapter(
          config,
          targetDirectory,
          topLevelInputPath,
          log,
          scalafmt
        )

        val scalaVer = scalaVersion.value
        val inputFiles = collectInputFiles(topLevelInputPath, log).toSet
        val cachedFun = FileFunction.cached(
          streams.value.cacheDirectory / s"sttp-openapi-src-$scalaVer",
          FileInfo.hash
        ) { input: Set[File] =>
          input.foldLeft(Set.empty[File]) { (result, inputFile) =>
            val generationResult = codegen.processSingleFile(inputFile)
            generationResult match {
              case Left(failure) =>
                log.warn(s"Couldn't process $inputFile because of $failure")
                result
              case Right(success) => result + success
            }
          }
        }
        cachedFun(inputFiles).toSeq
      }

    private def collectInputFiles(f: File, log: ManagedLogger): List[File] =
      if (f.exists()) {
        val these = f.listFiles
        these
          .filter(f => f.isFile && (f.ext == "yaml" || f.ext == "yml"))
          .toList ++ these
          .filter(_.isDirectory)
          .flatMap(collectInputFiles(_, log))
      } else {
        log.warn(
          s"[SttpOpenapi] Input directory $f does not exist. Skipping generation..."
        )
        List.empty
      }
  }

  import autoImport._

  private lazy val coreDeps = List(
    "com.softwaremill.sttp.client3" %% "core" % "3.3.0"
  )

  private lazy val circeDeps = List(
    "io.circe" %% "circe-core" % "0.13.0",
    "io.circe" %% "circe-generic" % "0.13.0",
    "io.circe" %% "circe-parser" % "0.13.0",
    "com.softwaremill.sttp.client3" %% "circe" % "3.3.0"
  )

  override def projectSettings: Seq[Def.Setting[_]] =
    Seq(
      sttpOpenApiOutputPath := (Compile / sourceManaged).value,
      sttpOpenApiInputPath := (Compile / resourceDirectory).value,
      sttpOpenApiJsonLibrary := JsonLibrary.Circe,
      sttpOpenApiHandleErrors := true,
      Compile / sourceGenerators += generateSources.taskValue,
      libraryDependencies ++= coreDeps ++ (sttpOpenApiJsonLibrary.value match {
        case JsonLibrary.Circe => circeDeps
      })
    )
}
